---
title: "Introduction to rgs3"
author: "Timothée Flutre (INRA)"
date: "`r format(Sys.time(), '%d/%m/%Y %H:%M:%S')`"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: TRUE
  html_document:
    toc: true
    toc_float: true
    number_sections: TRUE
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: TRUE
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Introduction to rgs3}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!--
setwd("~/src/rgs3/vignettes/")

library(devtools)
build_vignettes()

library(rmarkdown)
render("intro-rgs3.Rmd", "html_document")
-->

```{r knitr_setup, echo=FALSE}
library(knitr)
knitr::opts_chunk$set(fig.align="center")
```


# Preamble

The `rgs3` package can be downloaded from [GitHub](https://github.com/timflutre/rgs3).
To install it, we can follow the indications in the [`README.md`](https://github.com/timflutre/rgs3/blob/master/README.md) file.
Once this is done, we can load the package into R:

```{r, echo=FALSE}
if("package:rgs3" %in% search())
  detach("package:rgs3", unload=TRUE)
```

```{r load_pkg}
library(rgs3)
packageVersion("rgs3")
```

For the `rgs3` package to work successfully, the GS3 program should be already installed.
It should be available in our [PATH](https://en.wikipedia.org/wiki/PATH_%28variable%29), as `gs3.exe` for Windows and as `gs3` for others (such as GNU/Linux or Mac OS).
The GS3 program is available for download at the [web page](http://snp.toulouse.inra.fr/~alegarra/) of Andrés Legarra (INRA).
Note that this vignette requires a version at least as recent as January 6, 2016.

This R chunk is used to assess how much time it takes to execute the R code in this document until the end:
```{r time_0}
t0 <- proc.time()
```


# Model

To know exactly what the GS3 program can do, it is strongly advised to also read the GS3 [manual](http://snp.toulouse.inra.fr/~alegarra/manualgs3_last.pdf) as this introduction doesn't show all possible ways to use it.

Notations:

* $N$: number of trait measurements

* $Q$: number of generic covariates or cross-classified factors (modeled with fixed effects)

* $I$: number of individuals

* $P$: number of SNPs

* $J$: number of permanent environmental covariates (modeled with random effects)

* $\boldsymbol{y}$: $N \times 1$ vector of trait measurements

* $X$: $N \times Q$ design matrix of covariates or cross-classified factors

* $\boldsymbol{b}$: $Q \times 1$ vector of fixed effects

* $Z$: $N \times P$ design matrix of additive SNP genotypes

* $\boldsymbol{a}$: $P \times 1$ vector of random additive genotype effects

* $W$: $N \times P$ design matrix of dominant SNP genotypes

* $\boldsymbol{d}$: $P \times 1$ vector of random dominant genotype effects

* $T$: $N \times I$ design matrix of individuals

* $\boldsymbol{g}$: $I \times 1$ vector of random polygenic infinitesimal effects (pedigree-based)

* $S$: $N \times J$ design matrix of permanent environmental covariates

* $\boldsymbol{p}$: $J \times 1$ vector of random permanent environmental effects

* $\boldsymbol{e}$: $N \times 1$ vector of errors

* $\sigma_a^2, \sigma_d^2, \sigma_g^2, \sigma_p^2, \sigma_e^2$: variance components of each random effect

Likelihood:

$\boldsymbol{y} = X \boldsymbol{b} + Z \boldsymbol{a} + W \boldsymbol{d} + T \boldsymbol{g} + S \boldsymbol{p} + \boldsymbol{e}$

Estimate of the "generalized" genomic breeding value of individual $i$:

$EBV_i = \hat{g}_i + \boldsymbol{z}_i \hat{\boldsymbol{a}} + \boldsymbol{w}_i \hat{\boldsymbol{d}}$


# Simulation

A data set was simulated to illustrate how the `rgs3` package works:

1. SNP genotypes were simulated for $I$ individuals via the sequential coalescent with recombination model from [Staab et al (2015)](http://dx.doi.org/10.1093/bioinformatics/btu861);

2. $P$ SNPs were encoded as allele dose, filtered out if they had a minor allele frequency below 1%, and gathered into a matrix used to estimate the $I \times I$ additive relationships matrix $G$ using the first estimator from [VanRaden (2008)](http://dx.doi.org/10.3168/jds.2007-0980);

3. finally, the following model was used to simulate $N$ phenotypes over $Q$ years, with $N = Q \times I$:

$\boldsymbol{y} = X \boldsymbol{b} + T \boldsymbol{g} + \boldsymbol{e}$ where $\boldsymbol{g} \sim \mathcal{N}_I(\boldsymbol{0}, \sigma_g^2 G)$ and $\boldsymbol{e} \sim \mathcal{N}_N(\boldsymbol{0}, \sigma_e^2 \text{Id})$ with $\sigma_e^2 = 5$ and $\sigma_g^2 = 15$.

Note that, in GS3, it is assumed that $\boldsymbol{g} \sim \mathcal{N}_I(\boldsymbol{0}, \sigma_g^2 A)$ where $A$ is the numerator relationship matrix calculated from the pedigree.

Moreover, the fitted model will be:

$\boldsymbol{y} = X \boldsymbol{b} + Z \boldsymbol{a} + \boldsymbol{e}$ where $\boldsymbol{a} \sim \mathcal{N}_P(\boldsymbol{0}, \sigma_a^2 \text{Id})$ and $\boldsymbol{e} \sim \mathcal{N}_N(\boldsymbol{0}, \sigma_e^2 \text{Id})$

To check the inference results, we will use the following approximation, $\sigma_g^2 = \sigma_a^2 \times 2 \sum_p f_p (1 - f_p)$, where $f_p$ is the allele frequency of the $p$-th SNP (see [Gianola et al, 2009](http://dx.doi.org/10.1534/genetics.109.103952)).


# Load the data into R

Load the phenotypes:

```{r load_phenos}
phenos.file <- system.file("extdata", "phenos_df.txt.gz", package="rgs3")
tools::md5sum(path.expand(phenos.file))
phenos <- read.table(phenos.file, header=TRUE)
phenos$year <- as.factor(phenos$year)
str(phenos)
head(phenos)
phenos[phenos$geno == levels(phenos$geno)[1],]
(I <- nlevels(phenos$geno))
(Q <- nlevels(phenos$year))
(N <- nrow(phenos))
```

As can be seen above, the phenotype file contains `r ncol(phenos)` columns.
The first column corresponds to a covariate indicating the year at which the trait was measured.
This covariate has $Q=$ `r Q` levels.
The second column corresponds to the $I=$ `r I` individual identifiers.
The third column corresponds to the $N=$ `r N` trait measurements.

A quick look at the data is always helpful:

```{r plot_phenos, fig.width=5}
par(mar=c(4,4,2,1))
boxplot(phenos$response1 ~ phenos$year, notch=TRUE, horizontal=TRUE, las=1,
        main="Phenotypes", xlab="response", ylab="year")
```

We can see at least a "year" effect, as well as substantial within-year variation likely coming from both genetic and environmental sources.
The goal will be to quantify their respective contributions.

Load the genotypes (only SNPs with a minor allele frequency above 0.01 are available):

```{r load_genos}
genos.file <- system.file("extdata", "genos_mat.txt.gz", package="rgs3")
tools::md5sum(path.expand(genos.file))
genos <- as.matrix(read.table(genos.file))
dim(genos)
genos[1:3,1:6]
(P <- ncol(genos))
```

As can be seen above, the genotype file contains the matrix of genotypes for each individual at the $P=$ `r P` SNPs, encoded as allele dose (0/1/2).
Individuals are in rows and SNPs in columns.

We can have a quick look at the allele frequencies:

```{r plot_af, fig.width=5}
afs <- colMeans(genos, na.rm=TRUE) / 2
summary(afs) # mean should be 0.5 as reference alleles are chosen at random
par(mar=c(2,4,2,1))
hist(afs, breaks="FD", main="Allele frequencies",
     xlab="", ylab="Number of SNPs",
     col="grey", border="white", xlim=c(0, 1), las=1)
```

We can also have a quick look at minor allele frequencies:

```{r plot_maf, fig.width=5}
mafs <- apply(genos, 2, function(x){
  x <- x[complete.cases(x)]
  tmp <- sum(x) / (2 * length(x))
  ifelse(tmp <= 0.5, tmp, 1 - tmp)
})
par(mar=c(2,4,2,1))
hist(mafs, breaks="FD", main="Minor allele frequencies",
     xlab="", ylab="number of SNPs",
     col="grey", border="white", xlim=c(0, 0.5), las=1)
```

We can also have a quick look at the additive genomic relationships:

```{r plot_G}
afs <- colMeans(genos) / 2
M <- genos - 1
Pmat <- matrix(rep(1,nrow(genos))) %*% (2 * (afs - 0.5))
Z <- M - Pmat
G <- tcrossprod(Z, Z) / (2 * sum(afs * (1 - afs)))
G[1:3,1:3]
summary(diag(G)) # under HWE, average should be 1
summary(G[upper.tri(G)]) # under HWE, average should be 0
par(mar=c(1,1,2,1))
image(t(G)[,nrow(G):1], axes=FALSE, main="G")
```


# Quick check with another package

Load the true genotypic values:
```{r load_true_genovals}
genovals.file <- system.file("extdata", "genovals.txt.gz", package="rgs3")
tools::md5sum(path.expand(genovals.file))
genovals <- as.matrix(read.table(genovals.file, row.names=1))[,1]
head(genovals)
summary(genovals)
```

```{r rrBLUP, fig.width=5}
if(require(rrBLUP)){
  st <- system.time(
      fit.rrBLUP <- mixed.solve(y=phenos$response1,
                                Z=model.matrix(~ phenos$geno - 1),
                                K=G,
                                X=model.matrix(~ phenos$year),
                                method="REML", SE=TRUE, return.Hinv=TRUE))
  print(st)
  message(paste0("estimate of sigma.e2 = ", fit.rrBLUP$Ve))
  message(paste0("estimate of sigma.g2 = ", fit.rrBLUP$Vu))
  message(paste0("cor(true.g, pred.g) = ", cor(genovals,
                                               fit.rrBLUP$u[names(genovals)])))
  print(accuracy.rrBLUP <- lm(fit.rrBLUP$u[names(genovals)] ~ genovals))
  plot(x=genovals, y=fit.rrBLUP$u[names(genovals)], xlab="True breeding values",
       ylab="Predicted breeding values", main="Check with rrBLUP", las=1, asp=1)
  abline(v=0, h=0, a=0, b=1, lty=2); abline(accuracy.rrBLUP, col="red")
}
```

The estimates are quite close from the "true" values (i.e. those used to simulate the phenotypes).


# Write the data into files formatted for GS3

Encode the individual identifiers as consecutive numbers from $1$ to $I$:

```{r code_inds}
inds <- setNames(object=1:nlevels(phenos$geno),
                 nm=levels(phenos$geno))
head(inds)
```

Write the phenotype file in the GS3 format:

```{r write_phenos}
phenos.file.gs3 <- paste0(getwd(), "/phenos_gs3.txt")
writeDataForGs3(x=phenos, file=phenos.file.gs3, inds=inds, col.id=2,
                col.traits=3, binary.traits=FALSE)
```

Write the genotype file in the GS3 format:

```{r write_genos}
genos.file.gs3 <- paste0(getwd(), "/genos_gs3.txt")
writeGenosForGs3(x=genos, file=genos.file.gs3, inds=inds)
```


# Estimate parameters with GS3

Write the configuration file for GS3 (you can also use the helper function `getDefaultConfig`):

```{r write_config}
config.file <- paste0(getwd(), "/config_gs3_vce.txt")
(ptl <- data.frame(position=c(which(colnames(phenos) == "year"),
                              ncol(phenos) + 1),
                              ## ncol(phenos) + 1),
                              ## which(colnames(phenos) == "geno")),
                   type=c("cross",
                          "add_SNP"),
                          ## "dom_SNP"),
                          ## "perm_diagonal"),
                   nlevels=c(Q,
                             0),
                             ## 0),
                             ## I),
                   stringsAsFactors=FALSE))
config <- list(num.loci=P,
               method="VCE",
               simul="F",
               niter=1*10^4,
               burnin=1*10^3,
               thin=10,
               conv.crit="1d-8",
               correct=1000,
               vcs.file=paste0(getwd(), "/var_comp_samples.txt"),
               sol.file=paste0(getwd(), "/solutions.txt"),
               twc=c(which(colnames(phenos) == "response1"), 0),
               num.eff=nrow(ptl),
               ptl=ptl,
               vc=data.frame(var=c("vara", "vard", "varg", "varp", "vare"),
                             exp=c("2.52d-04","1.75d-06","3.56","2.15","0.19"),
                             df=rep("-2", 5),
                             stringsAsFactors=FALSE),
               rec.id=which(colnames(phenos) == "geno"),
               cont="F",
               mod=rep("T", nrow(ptl)),
               ap=c(1,10),
               dp=c(1,1),
               use.mix="F",
               blasso=FALSE)
isValidConfig(config=config)
writeConfigForGs3(config=config,
                  data.file=phenos.file.gs3,
                  ped.file=NULL,
                  genos.file=genos.file.gs3,
                  config.file=config.file)
```

Here is how the resulting configuration file looks like:

```{r read_config}
readLines(config.file)
```

Execute GS3:

```{r exec_gs3}
stdouterr.file <- paste0(getwd(), "/intro_stdouterr_gs3.txt")
system.time(retVal <- execGs3(config.file, stdouterr.file))
message(paste0("return value = ", retVal)) # "0" means "success"
```

The GS3 program outputs some messages (too long to display here):

```{r stdouterr}
stdouterr <- readLines(stdouterr.file)
```


# Assess estimated variances

If the [coda](https://cran.r-project.org/package=coda) package is installed, we can use the `vcs2mcmc` function from `rgs3` to read the output file from GS3 into an `mcmc.list` object.
But we won't use this function in this vignette as `coda` may not be available.

Load the variance components' samples:

```{r load_vcs}
vcs <- read.table(config$vcs.file, header=TRUE)
str(vcs)
```

Assess convergence visually, at least for some parameters:

```{r vcs_conv, fig.width=7}
par(mfrow=c(1,2), mar=c(4,4,2,1))
for(vc in c("vara","vare")){
  plot(vcs[,vc], las=1,
       xlab="iterations",
       ylab="samples",
       main=vc)
  abline(h=mean(vcs[,vc]), col="red")
  abline(v=101, lty=2)
  legend(ifelse(vc == "vara", "bottomright", "topright"),
         legend="posterior mean", col="red", lty=1, bty="n")
}
```

It looks like the chain converged, even though, to be more thorough, one should only declare convergence after checking it for all parameters.

Moreover, as indicated by the vertical, dotted line, we can discard more samples at the beginning:

```{r burnin}
idx.tokeep <- 101:nrow(vcs)
```

Look at posterior mean and variance of parameters of interest:

```{r posterior_vcs}
message(paste0("posterior mean of sigma.e2 = ",
               mean(vcs[idx.tokeep, "vare"])))
message(paste0("posterior sd of sigma.e2 = ",
               sd(vcs[idx.tokeep, "vare"])))
message(paste0("posterior mean of sigma.a2 = ",
               mean(vcs[idx.tokeep, "vara"])))
message(paste0("posterior sd of sigma.a2 = ",
               sd(vcs[idx.tokeep, "vara"])))
message(paste0("posterior mean of '2varapqpi' = ",
               mean(vcs[idx.tokeep, "X2varapqpi"])))
message(paste0("posterior sd of '2varapqpi' = ",
               sd(vcs[idx.tokeep, "X2varapqpi"])))
```

The estimates are quite close from the "true" values (i.e. those used to simulate the phenotypes, see section "Simulation" above).


# Assess estimated effects

The fixed and various SNP effects are found in the file specified via the variable `sol.file` (see above):
```{r load_estim-effects}
sols <- read.table(file=config$sol.file, header=TRUE)
str(sols)
table(sols$effect)
```

* The first `r Q` rows correspond to the `r Q` fixed effects.

* The remaining `r nrow(sols)-Q` rows correspond to the additive effects of the `r P` SNP genotypes.

```{r plot_snp-add, fig.width=5}
lim <- max(abs(sols$solution[sols$effect == 2]))
par(mar=c(2,4,2,1))
hist(sols$solution[sols$effect == 2], breaks="FD", xlim=c(-lim, lim),
     main="Additive effects of the SNPs",
     xlab="", ylab="number of SNPs",
     col="grey", border="white", las=1)
abline(v=0, lty=2)
```


# Assess predicted genotypic values

The various estimated genotypic values are saved in the file `<config.file>_EBVs`:
```{r load_EBVs}
ebvs <- read.table(file=paste0(config.file, "_EBVs"), header=TRUE)
ebvs <- ebvs[! duplicated(ebvs$id),]
str(ebvs)
rownames(ebvs) <- names(inds)
head(ebvs)
```

* The first column, `id`, corresponds to the identifiers of the individuals defined in the vector `inds` above.

* The second column, `g_aSNP`, corresponds to the sum of the posterior means of the additive effects of the SNP genotypes, $\sum_p \hat{a}_p = \boldsymbol{z}_i \hat{\boldsymbol{a}}$.

* The third column, `g_dSNP`, corresponds to the sum of the posterior means of the dominant effects of the SNP genotypes, $\sum_p \hat{d}_p = \boldsymbol{w}_i \hat{\boldsymbol{d}}$.

* The fourth column, `poly_anim`, corresponds to the posterior mean of the polygenic infinitesimal effect (pedigree-based), $\hat{g}_i$.

* The last column, `g_overall`, corresponds to the estimated "generalized" genomic breeding value, that is, the sum of the three previous columns.

We can have a quick look at the distribution of these gEBVs:
```{r plot_gEBVs, fig.width=5}
summary(ebvs$g_overall)
lim <- max(abs(ebvs$g_overall))
par(mar=c(2,4,2,1))
hist(ebvs$g_overall, breaks="FD", xlim=c(-lim, lim),
     main="gEBVs (with uncentered SNP genotypes)",
     xlab="", ylab="number of individuals",
     col="grey", border="white", las=1)
abline(v=0, lty=2)
```

The bias is explained by the fact that GS3 returns (biological) "genotypic" values instead of (statistical) "breeding" values (EBVs), despite of the output file name (see [Vitezica et al (2013)](http://dx.doi.org/10.1534/genetics.113.155176) for a thorough explanation):

* "genotypic" values: $u = Z a$ where $\forall i,j, \; Z_{ij} \in \{-1,0,1\}$ and $v = W d$ where $\forall i,j, \; W_{ij} \in \{0,1\}$;

* "breeding" values: $u_{ebv} = Z^\star \alpha$ where $\alpha = a + (1 - f_p) d$ is the additive substitution effect and $\forall i,j, \; Z_{ij}^\star \in \{-2 f_p, 1 - f_p, 2 - 2 f_p\}$, i.e. $Z$ is centered.

The difference between the true breeding values and the raw output from GS3 hence comes from the way SNP genotypes are encoded in $Z$ versus $Z^\star$:
```{r encoding_SNP-genos}
Z <- genos - 1
a.hat <- sols$solution[sols$effect == 2]
u.hat <- Z %*% a.hat
u.hat <- setNames(as.vector(u.hat), rownames(u.hat))
all.equal(u.hat, ebvs$g_aSNP, tolerance=10^(-6), check.attributes=FALSE)
alpha.hat <- sols$solution[sols$effect == 2] # all dominance effects are null in this analysis
Z.star <- Z - matrix(rep(1,nrow(genos))) %*% (2 * (afs - 0.5))
u.ebv <- Z.star %*% alpha.hat
u.ebv <- setNames(as.vector(u.ebv), rownames(u.ebv))
summary(u.ebv)
```

Check with the genotypic values used to simulate the phenotypes:
```{r check_genovals, fig.width=5}
cor(x=genovals, ebvs[names(genovals), "g_overall"], method="pearson")
cor(x=genovals, u.ebv[names(genovals)], method="pearson")
(accuracy.GS3 <- lm(u.ebv[names(genovals)] ~ genovals))
plot(x=genovals, y=u.ebv[names(genovals)], asp=1, las=1,
     xlab="True genotypic values", ylab="Predicted genotypic values",
     main="Check with GS3")
abline(h=0, v=0, a=0, b=1, lty=2); abline(accuracy.GS3, col="red")
```


# Remove output files

```{r rmv_out_files}
for(f in c(config.file, phenos.file.gs3, genos.file.gs3, stdouterr.file,
           "config_gs3_vce.txt_EBVs", "config_gs3_vce.txt_cont", "freq",
           "solutions.txt", "var_comp_samples.txt"))
  if(file.exists(f))
    file.remove(f)
```



# Acknowledgments

* Andrés Legarra


# Appendix

```{r info}
t1 <- proc.time(); t1 - t0
print(sessionInfo(), locale=FALSE)
```
