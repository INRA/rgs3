---
title: "Introduction to rgs3"
author: "Timothée Flutre"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Introduction to rgs3}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


## Preamble

The `rgs3` package can be downloaded from [GitHub](https://github.com/timflutre/rgs3).
To install it, follow the indications in the `README` file.
Once this is done, you can load it into R:

```{r load_pkg}
library(rgs3)
```

For the `rgs3` package to work successfully, the GS3 program should be already installed on your machine.
It should be available in your [PATH](https://en.wikipedia.org/wiki/PATH_%28variable%29) named as `gs3` for Linux and `gs3.exe` for Windows.
You can download GS3 from the [web page](http://snp.toulouse.inra.fr/~alegarra/) of Andrés Legarra (INRA Toulouse).
Note that this vignette requires a version as recent as January 6, 2016.


## Model

To know exactly what the GS3 program can do, it is strongly advised to also read the GS3 [manual](http://snp.toulouse.inra.fr/~alegarra/manualgs3_last.pdf) as this introduction doesn't show all possible ways to use it.

Notations:

* $N$: number of trait measurements

* $Q$: number of generic covariates or cross-classified factors (modeled with fixed effects)

* $I$: number of individuals

* $P$: number of SNPs

* $J$: number of permanent environmental covariates (modeled with random effects)

* $\boldsymbol{y}$: $N \times 1$ vector of trait measurements

* $X$: $N \times Q$ design matrix of covariates or cross-classified factors

* $\boldsymbol{b}$: $Q \times 1$ vector of fixed effects

* $Z$: $N \times P$ design matrix of additive SNP genotypes

* $\boldsymbol{a}$: $P \times 1$ vector of random additive genotype effects

* $W$: $N \times P$ design matrix of dominant SNP genotypes

* $\boldsymbol{d}$: $P \times 1$ vector of random dominant genotype effects

* $T$: $N \times I$ design matrix of individuals

* $\boldsymbol{g}$: $I \times 1$ vector of random polygenic infinitesimal effects (pedigree-based)

* $S$: $N \times J$ design matrix of permanent environmental covariates

* $\boldsymbol{p}$: $J \times 1$ vector of random permanent environmental effects

* $\boldsymbol{e}$: $N \times 1$ vector of errors

* $\sigma_a^2, \sigma_d^2, \sigma_g^2, \sigma_p^2, \sigma_e^2$: variance components of each random effect

Likelihood:

$\boldsymbol{y} = X \boldsymbol{b} + Z \boldsymbol{a} + W \boldsymbol{d} + T \boldsymbol{g} + S \boldsymbol{p} + \boldsymbol{e}$

Estimate of the "generalized" genomic breeding value of individual $i$:

$EBV_i = \hat{g}_i + \boldsymbol{z}_i \hat{\boldsymbol{a}} + \boldsymbol{w}_i \hat{\boldsymbol{d}}$


## Simulation

A data set was simulated to illustrate how the `rgs3` package works:

1. SNP genotypes were simulated for $I$ individuals via the sequential coalescent with recombination model from [Staab et al (2015)](http://dx.doi.org/10.1093/bioinformatics/btu861);

2. $P$ SNPs with a minor allele frequency above 0.01 were encoded as allele dose and gathered into a matrix $Z$, which was then used to estimate the $I \times I$ additive genomic relationships matrix $G$ using the first estimator from [VanRaden (2008)](http://dx.doi.org/10.3168/jds.2007-0980);

3. finally, the following model was used to simulate $N$ phenotypes over $Q$ years, with $N = Q \times I$:

$\boldsymbol{y} = X \boldsymbol{b} + T \boldsymbol{g} + \boldsymbol{e}$ where $\boldsymbol{g} \sim \mathcal{N}_I(\boldsymbol{0}, \sigma_g^2 G)$ and $\boldsymbol{e} \sim \mathcal{N}_N(\boldsymbol{0}, \sigma_e^2 \text{Id})$ with $\sigma_e^2 = 5$ and $\sigma_g^2 = 15$.

Note that, in GS3, it is assumed that $\boldsymbol{g} \sim \mathcal{N}_I(\boldsymbol{0}, \sigma_g^2 A)$ where $A$ is the numerator relationship matrix calculated from the pedigree.

Moreover, the fitted model will be:

$\boldsymbol{y} = X \boldsymbol{b} + Z \boldsymbol{a} + \boldsymbol{e}$ where $\boldsymbol{a} \sim \mathcal{N}_P(\boldsymbol{0}, \sigma_a^2 \text{Id})$ and $\boldsymbol{e} \sim \mathcal{N}_N(\boldsymbol{0}, \sigma_e^2 \text{Id})$

To check the inference results, we will use the following approximation, $\sigma_g^2 = \sigma_a^2 \times 2 \sum_p f_p (1 - f_p)$, where $f_p$ is the minor allele frequency of the $p$-th SNP (see [Gianola et al, 2009](http://dx.doi.org/10.1534/genetics.109.103952)).


## Load the data into R

Load the phenotypes:

```{r load_phenos}
phenos.file <- system.file("extdata", "phenos_df.txt.gz", package="rgs3")
phenos <- read.table(phenos.file, header=TRUE)
phenos$year <- as.factor(phenos$year)
str(phenos)
head(phenos)
phenos[phenos$ind == levels(phenos$ind)[1],]
```

As can be seen above, the phenotype file contains `r ncol(phenos)` columns.
The first column corresponds to a covariate indicating the year at which the trait was measured.
This covariate has $Q=$ `r (Q <- nlevels(phenos$year))` levels.
The second column corresponds to the $I=$ `r (I <- nlevels(phenos$ind))` individual identifiers.
The third column corresponds to the $N=$ `r (N <- nrow(phenos))` trait measurements.

A quick look at the data is always helpful:

```{r plot_phenos, fig.width=5}
par(mar=c(4,4,2,1))
boxplot(phenos$response ~ phenos$year, notch=TRUE, horizontal=TRUE,
        main="Phenotypes", xlab="response", ylab="year")
```

Here it shows at least one "year" effect, as well as substantial within-year variation coming from genetic and environmental sources.
The goal will be to quantify their respective contributions.

Load the genotypes:

```{r load_genos}
genos.file <- system.file("extdata", "genos_mat.txt.gz", package="rgs3")
genos <- as.matrix(read.table(genos.file))
dim(genos)
genos[1:3,1:6]
```

As can be seen above, the genotype file contains the matrix of genotypes for each individual at the $P=$ `r (P <- ncol(genos))` SNPs, encoded as allele dose (0/1/2).
Individuals are in rows and SNPs in columns.

We can have a quick look at minor allele frequencies:

```{r plot_maf, fig.width=5}
par(mar=c(2,4,2,1))
mafs <- apply(genos, 2, function(x){
  x <- x[complete.cases(x)]
  tmp <- sum(x) / (2 * length(x))
  ifelse(tmp <= 0.5, tmp, 1 - tmp)
})
hist(mafs, breaks="FD", main="Minor allele frequencies",
     xlab="", ylab="number of SNPs",
     col="grey", border="white", xlim=c(0, 0.5), las=1)
```

We can also have a quick look at the additive genomic relationships:

```{r plot_G}
M <- genos - 1
Pmat <- matrix(rep(1,nrow(genos))) %*% (2 * (mafs - 0.5))
Z <- M - Pmat
G <- tcrossprod(Z, Z) / (2 * sum(mafs * (1 - mafs)))
G[1:3,1:3]
par(mar=c(1,1,2,1))
image(t(G)[,nrow(G):1], axes=FALSE, main="G")
```


## Quick check with another package

```{r rrBLUP}
if(require(rrBLUP)){
  st <- system.time(
      fit.rrBLUP <- mixed.solve(y=phenos$response,
                                Z=model.matrix(~ phenos$ind - 1),
                                K=G,
                                X=model.matrix(~ phenos$year),
                                method="REML", SE=TRUE, return.Hinv=TRUE))
  print(st)
  message(paste0("estimate of sigma.e2 = ", fit.rrBLUP$Ve))
  message(paste0("estimate of sigma.g2 = ", fit.rrBLUP$Vu))
}
```

The estimates are quite close from the "true" values (i.e. those used to simulate the phenotypes).


## Write the data into files formatted for GS3

Encode the individual identifiers as consecutive numbers from $1$ to $I$:

```{r code_inds}
inds <- setNames(object=1:nlevels(phenos$ind),
                 nm=levels(phenos$ind))
head(inds)
```

Write the phenotype file in the GS3 format:

```{r write_phenos}
phenos.file.gs3 <- paste0(getwd(), "/phenos_gs3.txt")
writeDataForGs3(x=phenos, file=phenos.file.gs3,
                inds=inds, col.id=2, col.trait=3)
```

Write the genotype file in the GS3 format:

```{r write_genos}
genos.file.gs3 <- paste0(getwd(), "/genos_gs3.txt")
writeGenosForGs3(x=genos, file=genos.file.gs3, inds=inds)
```


## Estimate parameters with GS3

Write the configuration file for GS3:

```{r write_config}
config.file <- paste0(getwd(), "/config_gs3_vce.txt")
vcs.file <- paste0(getwd(), "/var_comp_samples.txt")
sol.file <- paste0(getwd(), "/solutions.txt")
(ptl <- data.frame(position=c(which(colnames(phenos) == "year"),
                              ncol(phenos) + 1),
                              ## which(colnames(phenos) == "ind")),
                   type=c("cross",
                          "add_SNP"),
                          ## "perm_diagonal"),
                   nlevels=c(Q,
                             0),
                             ## I),
                   stringsAsFactors=FALSE))
writeConfigForGs3(config.file=config.file,
                  data.file=phenos.file.gs3,
                  ped.file=NULL,
                  genos.file=genos.file.gs3,
                  num.loci=P,
                  method="VCE",
                  simul="F",
                  niter=2*10^4,
                  burnin=2*10^3,
                  thin=10,
                  vcs.file=vcs.file,
                  sol.file=sol.file,
                  twc=c(which(colnames(phenos) == "response"), 0),
                  num.eff=nrow(ptl),
                  ptl=ptl,
                  vc=data.frame(var=c("vara","vard","varg","varp","vare"),
                                exp=c("2.52d-04","1.75d-06","3.56","2.15","0.19"),
                                df=rep("-2", 5),
                                stringsAsFactors=FALSE),
                  rec.id=which(colnames(phenos) == "ind"),
                  cont="F",
                  mod=rep("T", nrow(ptl)),
                  ap=c(1, 10),
                  dp=c(1, 1),
                  use.mix="F",
                  blasso=FALSE)
```

Here is how the resulting configuration file looks like:

```{r read_config}
readLines(config.file)
```

Execute GS3:

```{r exec_gs3}
stdouterr.file <- paste0(getwd(), "/intro_stdouterr_gs3.txt")
system.time(retVal <- execGs3(config.file, stdouterr.file))
message(paste0("return value = ", retVal))
```

The GS3 program outputs some messages (too long to display here):

```{r stdouterr}
stdouterr <- readLines(stdouterr.file)
```


## Assess inference on variance components

Load the variance components' samples:

```{r load_vcs}
vcs <- read.table(vcs.file, header=TRUE)
str(vcs)
```

Assess convergence, at least for some parameters:

```{r vcs_conv, fig.width=7}
par(mfrow=c(1,2), mar=c(4,4,2,1))
for(vc in c("vara","vare")){
  plot(vcs[,vc], las=1,
       xlab="iterations",
       ylab="samples",
       main=vc)
  abline(h=mean(vcs[,vc]), col="red")
  abline(v=101, lty=2)
  legend("bottomright", legend="posterior mean", col="red", lty=1, bty="n")
}
```

It looks like the chain converged (even though, to be more thorough, one should only declare convergence after checking it for all parameters).
But, as indicated by the vertical, dotted line, we can increase a little bit more the burn-in:

```{r burnin}
idx.tokeep <- 101:nrow(vcs)
```

Look at posterior mean and variance of parameters of interest:

```{r posterior_vcs}
message(paste0("posterior mean of sigma.e2 = ",
               mean(vcs[idx.tokeep, "vare"])))
message(paste0("posterior variance of sigma.e2 = ",
               var(vcs[idx.tokeep, "vare"])))
message(paste0("posterior mean of sigma.a2 = ",
               mean(vcs[idx.tokeep, "vara"])))
message(paste0("posterior variance of sigma.a2 = ",
               var(vcs[idx.tokeep, "vara"])))
message(paste0("approximated estimate of sigma.g2 = ",
               mean(vcs[idx.tokeep, "vara"]) * 2 * sum(mafs * (1 - mafs))))
```

The estimates are quite close from the "true" values (i.e. those used to simulate the phenotypes).


## Acknowledgments

* Andrés Legarra


## Appendix

```{r info}
print(sessionInfo(), locale=FALSE)
```
